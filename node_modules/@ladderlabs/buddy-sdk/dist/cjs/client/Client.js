"use strict";
exports.__esModule = true;
exports.Client = void 0;
var tslib_1 = require("tslib");
var anchor = tslib_1.__importStar(require("@project-serum/anchor"));
var type_1 = require("../utils/type");
var buddylink_json_1 = tslib_1.__importDefault(require("../idl/buddylink.json"));
var OrganizationProvider_1 = require("./providers/OrganizationProvider");
var MemberProvider_1 = require("./providers/MemberProvider");
var TreasuryProvider_1 = require("./providers/TreasuryProvider");
var BuddyProvider_1 = require("./providers/BuddyProvider");
var Transfers_1 = require("./builders/Transfers");
var Initializer_1 = require("./builders/Initializer");
var AmbassadorProvider_1 = require("./providers/AmbassadorProvider");
var NFT_1 = require("./builders/NFT");
var PDA_1 = require("./providers/PDA");
var compression_1 = require("../utils/compression");
var Accounts_1 = require("./builders/Accounts");
var ENCRYPT_NAME_LENGTH = 18;
var ENCRYPT_SHARES_NAME = 5;
var Client = /** @class */ (function () {
    function Client(connection, wallet, programId) {
        if (programId === void 0) { programId = type_1.MAINNET_PROGRAM_ID; }
        var provider = new anchor.AnchorProvider(connection, null, anchor.AnchorProvider.defaultOptions());
        anchor.setProvider(provider);
        var program = new anchor.Program(buddylink_json_1["default"], programId);
        this.program = program;
        this.organization = new OrganizationProvider_1.OrganizationProvider(program, wallet);
        this.member = new MemberProvider_1.MemberProvider(program, wallet);
        this.treasury = new TreasuryProvider_1.TreasuryProvider(program, wallet);
        this.buddy = new BuddyProvider_1.BuddyProvider(program, wallet);
        this.ambassador = new AmbassadorProvider_1.AmbassadorProvider(program, wallet);
        this.transfer = new Transfers_1.Transfer(program, wallet);
        this.initialize = new Initializer_1.Initializer(program, wallet);
        this.nft = new NFT_1.NFT(program, wallet);
        this.pda = new PDA_1.PDA(program);
        this.accounts = new Accounts_1.Accounts(program);
    }
    Client.prototype.inject = function (wallet) {
        this.organization = new OrganizationProvider_1.OrganizationProvider(this.program, wallet);
        this.member = new MemberProvider_1.MemberProvider(this.program, wallet);
        this.treasury = new TreasuryProvider_1.TreasuryProvider(this.program, wallet);
        this.buddy = new BuddyProvider_1.BuddyProvider(this.program, wallet);
        this.ambassador = new AmbassadorProvider_1.AmbassadorProvider(this.program, wallet);
        this.transfer = new Transfers_1.Transfer(this.program, wallet);
        this.initialize = new Initializer_1.Initializer(this.program, wallet);
        this.nft = new NFT_1.NFT(this.program, wallet);
        this.pda = new PDA_1.PDA(this.program);
        this.accounts = new Accounts_1.Accounts(this.program);
        return this;
    };
    Client.prototype.getProgramId = function () {
        return this.program.programId;
    };
    Client.generateProfileName = function () {
        var length = 18;
        var characters = "abcdefghijklmnopqrstuvwxyz0123456789";
        var result = "";
        for (var i = 0; i < length; i++) {
            var randomIndex = Math.floor(Math.random() * characters.length);
            result += characters.charAt(randomIndex);
        }
        return result;
    };
    Client.generateMemberName = function () {
        var length = 16;
        var characters = "abcdefghijklmnopqrstuvwxyz0123456789";
        var result = "";
        for (var i = 0; i < length; i++) {
            var randomIndex = Math.floor(Math.random() * characters.length);
            result += characters.charAt(randomIndex);
        }
        return result;
    };
    Client.decryptHash = function (hash) {
        if (!hash.endsWith("$")) {
            return [[hash.toLowerCase()], [10000]];
        }
        else {
            var decryptHash = (0, compression_1.decrypt)(hash.substring(0, hash.length - 1));
            var buddyNames = [];
            var shares = [];
            var i = 0;
            // ignores the last number. it for future proofing and to remove the $ at the end
            while (i < decryptHash.length - 6) {
                var name_1 = decryptHash
                    .substring(i, i + ENCRYPT_NAME_LENGTH)
                    .replace(/A+$/, "");
                i += ENCRYPT_NAME_LENGTH;
                var share = decryptHash
                    .substring(i, i + ENCRYPT_SHARES_NAME)
                    .replace(/^0+/, "");
                i += ENCRYPT_SHARES_NAME;
                buddyNames.push(name_1);
                shares.push(parseInt(share));
            }
            return [buddyNames, shares];
        }
    };
    Client.encryptHash = function (owners, shares) {
        var lastNumber = 1000;
        var stringToEncrypt = "";
        for (var i = 0; i < owners.length; i++) {
            var name_2 = owners[i].toLowerCase().padEnd(ENCRYPT_NAME_LENGTH, "A");
            var share = shares[i].toString().padStart(ENCRYPT_SHARES_NAME, "0");
            stringToEncrypt += name_2 + share;
        }
        stringToEncrypt += lastNumber.toString().padStart(5, "0");
        return (0, compression_1.encrypt)(stringToEncrypt) + "$";
    };
    return Client;
}());
exports.Client = Client;
//# sourceMappingURL=Client.js.map