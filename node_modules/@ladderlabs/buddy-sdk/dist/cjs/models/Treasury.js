"use strict";
exports.__esModule = true;
exports.Treasury = void 0;
var tslib_1 = require("tslib");
var web3_js_1 = require("@solana/web3.js");
var type_1 = require("../utils/type");
var Buddy_1 = require("./Buddy");
var claim_1 = require("../instructions/claim/claim");
var claimNoMultiLevel_1 = require("../instructions/claim/claimNoMultiLevel");
var transferUp_1 = require("../instructions/transfers/transferUp");
var pda_1 = require("../utils/pda");
var type_2 = require("../utils/type");
var Treasury = /** @class */ (function () {
    function Treasury(treasury, program, wallet) {
        this.account = treasury;
        this.wallet = wallet;
        this.program = program;
    }
    Treasury.prototype.refresh = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = this;
                        _b = [{ pda: this.account.pda }];
                        return [4 /*yield*/, this.program.account.treasury.fetch(this.account.pda)];
                    case 1:
                        _a.account = tslib_1.__assign.apply(void 0, _b.concat([(_c.sent())]));
                        return [2 /*return*/, this];
                }
            });
        });
    };
    Treasury.prototype.getOwners = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var owners, buddies, buddyInstances, i;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        owners = this.account.owners.map(function (owner) { return owner.ownerPda; });
                        return [4 /*yield*/, this.program.account.buddy.fetchMultiple(owners)];
                    case 1:
                        buddies = (_a.sent()).filter(Boolean);
                        buddyInstances = [];
                        for (i = 0; i < buddies.length; i++) {
                            buddyInstances.push(new Buddy_1.Buddy(tslib_1.__assign(tslib_1.__assign({}, buddies[i]), { pda: owners[i] }), this.program, this.wallet));
                        }
                        return [2 /*return*/, buddyInstances];
                }
            });
        });
    };
    // return in lamports since we dont know the decimals of spl tokens
    Treasury.prototype.getClaimableBalance = function (buddyPDA) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var masterOrg, owner, buddy, amount, noMultiLevelAmount, treasuryATA, rawBalance, accountInfo, _a, multiLevelAmount, frozenAmounts;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.program.account.masterOrganization.all()];
                    case 1:
                        masterOrg = (_b.sent())[0];
                        owner = this.account.owners[0];
                        if (buddyPDA) {
                            owner = this.account.owners.find(function (owner) { return owner.ownerPda.toString() === buddyPDA.toString(); });
                        }
                        if (!owner)
                            throw type_1.TREASURY_OWNER_MISMATCH;
                        return [4 /*yield*/, this.program.account.buddy.fetchNullable(owner.ownerPda)];
                    case 2:
                        buddy = _b.sent();
                        if (!buddy)
                            throw type_1.BUDDY_DOESNT_EXIST;
                        amount = 0;
                        noMultiLevelAmount = this.account.amountNoMultiLevel.toNumber() *
                            (owner.share / 10000) *
                            (1 - masterOrg.account.shareKeptInBps / 10000) -
                            owner.noMultiLevel.frozen.toNumber();
                        return [4 /*yield*/, (0, pda_1.getTokenAccount)(this.account.pda, this.account.mint)];
                    case 3:
                        treasuryATA = _b.sent();
                        rawBalance = 0;
                        if (!(this.account.mint.toString() === web3_js_1.PublicKey["default"].toString())) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.program.provider.connection.getAccountInfo(this.account.pda)];
                    case 4:
                        accountInfo = (_b.sent());
                        _a = accountInfo.lamports;
                        return [4 /*yield*/, this.program.provider.connection.getMinimumBalanceForRentExemption(accountInfo.data.length)];
                    case 5:
                        rawBalance =
                            _a -
                                (_b.sent()) -
                                this.account.amountNoMultiLevel.toNumber() -
                                owner.withMultiLevel.frozen.toNumber();
                        return [3 /*break*/, 8];
                    case 6: return [4 /*yield*/, this.program.provider.connection.getTokenAccountBalance(treasuryATA)];
                    case 7:
                        rawBalance =
                            +(_b.sent()).value.amount -
                                this.account.amountNoMultiLevel.toNumber() -
                                owner.withMultiLevel.frozen.toNumber();
                        _b.label = 8;
                    case 8:
                        multiLevelAmount = rawBalance *
                            (owner.share / 10000) *
                            (1 -
                                masterOrg.account.shareKeptInBps / 10000 -
                                (buddy.referrerTreasuryPda.toString() !== web3_js_1.PublicKey["default"].toString()
                                    ? type_2.FORCED_REFERRER_BPS / 10000
                                    : 0));
                        frozenAmounts = owner.noMultiLevel.frozen.toNumber() +
                            owner.withMultiLevel.frozen.toNumber();
                        amount += multiLevelAmount + noMultiLevelAmount + frozenAmounts;
                        return [2 /*return*/, amount];
                }
            });
        });
    };
    Treasury.prototype.claim = function (buddyPDA, isMultiLevel) {
        if (isMultiLevel === void 0) { isMultiLevel = true; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var finalPDA;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.wallet)
                            throw type_1.NO_WALLET_ERROR;
                        finalPDA = buddyPDA;
                        if (!buddyPDA) {
                            finalPDA = this.account.owners[0].ownerPda;
                        }
                        if (!isMultiLevel) return [3 /*break*/, 2];
                        return [4 /*yield*/, (0, claim_1.claim)(this.program, this.wallet, finalPDA, this.account.pda)];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2: return [4 /*yield*/, (0, claimNoMultiLevel_1.claimNoMultiLevel)(this.program, this.wallet, finalPDA, this.account.pda)];
                    case 3: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Treasury.prototype.transferUp = function (buddyPDA, treasuryPDA) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.wallet)
                            throw type_1.NO_WALLET_ERROR;
                        return [4 /*yield*/, (0, transferUp_1.transferUp)(this.program, this.wallet, buddyPDA, treasuryPDA)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return Treasury;
}());
exports.Treasury = Treasury;
//# sourceMappingURL=Treasury.js.map