import { __assign, __awaiter, __generator } from "tslib";
import { PublicKey } from "@solana/web3.js";
import { BUDDY_DOESNT_EXIST, NO_WALLET_ERROR, TREASURY_OWNER_MISMATCH, } from "../utils/type";
import { Buddy } from "./Buddy";
import { claim as claimInstructions } from "../instructions/claim/claim";
import { claimNoMultiLevel } from "../instructions/claim/claimNoMultiLevel";
import { transferUp } from "../instructions/transfers/transferUp";
import { getTokenAccount } from "../utils/pda";
import { FORCED_REFERRER_BPS } from "../utils/type";
var Treasury = /** @class */ (function () {
    function Treasury(treasury, program, wallet) {
        this.account = treasury;
        this.wallet = wallet;
        this.program = program;
    }
    Treasury.prototype.refresh = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = this;
                        _b = [{ pda: this.account.pda }];
                        return [4 /*yield*/, this.program.account.treasury.fetch(this.account.pda)];
                    case 1:
                        _a.account = __assign.apply(void 0, _b.concat([(_c.sent())]));
                        return [2 /*return*/, this];
                }
            });
        });
    };
    Treasury.prototype.getOwners = function () {
        return __awaiter(this, void 0, void 0, function () {
            var owners, buddies, buddyInstances, i;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        owners = this.account.owners.map(function (owner) { return owner.ownerPda; });
                        return [4 /*yield*/, this.program.account.buddy.fetchMultiple(owners)];
                    case 1:
                        buddies = (_a.sent()).filter(Boolean);
                        buddyInstances = [];
                        for (i = 0; i < buddies.length; i++) {
                            buddyInstances.push(new Buddy(__assign(__assign({}, buddies[i]), { pda: owners[i] }), this.program, this.wallet));
                        }
                        return [2 /*return*/, buddyInstances];
                }
            });
        });
    };
    // return in lamports since we dont know the decimals of spl tokens
    Treasury.prototype.getClaimableBalance = function (buddyPDA) {
        return __awaiter(this, void 0, void 0, function () {
            var masterOrg, owner, buddy, amount, noMultiLevelAmount, treasuryATA, rawBalance, accountInfo, _a, multiLevelAmount, frozenAmounts;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.program.account.masterOrganization.all()];
                    case 1:
                        masterOrg = (_b.sent())[0];
                        owner = this.account.owners[0];
                        if (buddyPDA) {
                            owner = this.account.owners.find(function (owner) { return owner.ownerPda.toString() === buddyPDA.toString(); });
                        }
                        if (!owner)
                            throw TREASURY_OWNER_MISMATCH;
                        return [4 /*yield*/, this.program.account.buddy.fetchNullable(owner.ownerPda)];
                    case 2:
                        buddy = _b.sent();
                        if (!buddy)
                            throw BUDDY_DOESNT_EXIST;
                        amount = 0;
                        noMultiLevelAmount = this.account.amountNoMultiLevel.toNumber() *
                            (owner.share / 10000) *
                            (1 - masterOrg.account.shareKeptInBps / 10000) -
                            owner.noMultiLevel.frozen.toNumber();
                        return [4 /*yield*/, getTokenAccount(this.account.pda, this.account.mint)];
                    case 3:
                        treasuryATA = _b.sent();
                        rawBalance = 0;
                        if (!(this.account.mint.toString() === PublicKey["default"].toString())) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.program.provider.connection.getAccountInfo(this.account.pda)];
                    case 4:
                        accountInfo = (_b.sent());
                        _a = accountInfo.lamports;
                        return [4 /*yield*/, this.program.provider.connection.getMinimumBalanceForRentExemption(accountInfo.data.length)];
                    case 5:
                        rawBalance =
                            _a -
                                (_b.sent()) -
                                this.account.amountNoMultiLevel.toNumber() -
                                owner.withMultiLevel.frozen.toNumber();
                        return [3 /*break*/, 8];
                    case 6: return [4 /*yield*/, this.program.provider.connection.getTokenAccountBalance(treasuryATA)];
                    case 7:
                        rawBalance =
                            +(_b.sent()).value.amount -
                                this.account.amountNoMultiLevel.toNumber() -
                                owner.withMultiLevel.frozen.toNumber();
                        _b.label = 8;
                    case 8:
                        multiLevelAmount = rawBalance *
                            (owner.share / 10000) *
                            (1 -
                                masterOrg.account.shareKeptInBps / 10000 -
                                (buddy.referrerTreasuryPda.toString() !== PublicKey["default"].toString()
                                    ? FORCED_REFERRER_BPS / 10000
                                    : 0));
                        frozenAmounts = owner.noMultiLevel.frozen.toNumber() +
                            owner.withMultiLevel.frozen.toNumber();
                        amount += multiLevelAmount + noMultiLevelAmount + frozenAmounts;
                        return [2 /*return*/, amount];
                }
            });
        });
    };
    Treasury.prototype.claim = function (buddyPDA, isMultiLevel) {
        if (isMultiLevel === void 0) { isMultiLevel = true; }
        return __awaiter(this, void 0, void 0, function () {
            var finalPDA;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.wallet)
                            throw NO_WALLET_ERROR;
                        finalPDA = buddyPDA;
                        if (!buddyPDA) {
                            finalPDA = this.account.owners[0].ownerPda;
                        }
                        if (!isMultiLevel) return [3 /*break*/, 2];
                        return [4 /*yield*/, claimInstructions(this.program, this.wallet, finalPDA, this.account.pda)];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2: return [4 /*yield*/, claimNoMultiLevel(this.program, this.wallet, finalPDA, this.account.pda)];
                    case 3: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Treasury.prototype.transferUp = function (buddyPDA, treasuryPDA) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.wallet)
                            throw NO_WALLET_ERROR;
                        return [4 /*yield*/, transferUp(this.program, this.wallet, buddyPDA, treasuryPDA)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return Treasury;
}());
export { Treasury };
//# sourceMappingURL=Treasury.js.map