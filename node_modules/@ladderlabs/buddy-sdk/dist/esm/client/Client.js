import * as anchor from "@project-serum/anchor";
import { MAINNET_PROGRAM_ID } from "../utils/type";
import idl from "../idl/buddylink.json";
import { OrganizationProvider } from "./providers/OrganizationProvider";
import { MemberProvider } from "./providers/MemberProvider";
import { TreasuryProvider } from "./providers/TreasuryProvider";
import { BuddyProvider } from "./providers/BuddyProvider";
import { Transfer } from "./builders/Transfers";
import { Initializer } from "./builders/Initializer";
import { AmbassadorProvider } from "./providers/AmbassadorProvider";
import { NFT } from "./builders/NFT";
import { PDA } from "./providers/PDA";
import { decrypt, encrypt } from "../utils/compression";
import { Accounts } from "./builders/Accounts";
var ENCRYPT_NAME_LENGTH = 18;
var ENCRYPT_SHARES_NAME = 5;
var Client = /** @class */ (function () {
    function Client(connection, wallet, programId) {
        if (programId === void 0) { programId = MAINNET_PROGRAM_ID; }
        var provider = new anchor.AnchorProvider(connection, null, anchor.AnchorProvider.defaultOptions());
        anchor.setProvider(provider);
        var program = new anchor.Program(idl, programId);
        this.program = program;
        this.organization = new OrganizationProvider(program, wallet);
        this.member = new MemberProvider(program, wallet);
        this.treasury = new TreasuryProvider(program, wallet);
        this.buddy = new BuddyProvider(program, wallet);
        this.ambassador = new AmbassadorProvider(program, wallet);
        this.transfer = new Transfer(program, wallet);
        this.initialize = new Initializer(program, wallet);
        this.nft = new NFT(program, wallet);
        this.pda = new PDA(program);
        this.accounts = new Accounts(program);
    }
    Client.prototype.inject = function (wallet) {
        this.organization = new OrganizationProvider(this.program, wallet);
        this.member = new MemberProvider(this.program, wallet);
        this.treasury = new TreasuryProvider(this.program, wallet);
        this.buddy = new BuddyProvider(this.program, wallet);
        this.ambassador = new AmbassadorProvider(this.program, wallet);
        this.transfer = new Transfer(this.program, wallet);
        this.initialize = new Initializer(this.program, wallet);
        this.nft = new NFT(this.program, wallet);
        this.pda = new PDA(this.program);
        this.accounts = new Accounts(this.program);
        return this;
    };
    Client.prototype.getProgramId = function () {
        return this.program.programId;
    };
    Client.generateProfileName = function () {
        var length = 18;
        var characters = "abcdefghijklmnopqrstuvwxyz0123456789";
        var result = "";
        for (var i = 0; i < length; i++) {
            var randomIndex = Math.floor(Math.random() * characters.length);
            result += characters.charAt(randomIndex);
        }
        return result;
    };
    Client.generateMemberName = function () {
        var length = 16;
        var characters = "abcdefghijklmnopqrstuvwxyz0123456789";
        var result = "";
        for (var i = 0; i < length; i++) {
            var randomIndex = Math.floor(Math.random() * characters.length);
            result += characters.charAt(randomIndex);
        }
        return result;
    };
    Client.decryptHash = function (hash) {
        if (!hash.endsWith("$")) {
            return [[hash.toLowerCase()], [10000]];
        }
        else {
            var decryptHash = decrypt(hash.substring(0, hash.length - 1));
            var buddyNames = [];
            var shares = [];
            var i = 0;
            // ignores the last number. it for future proofing and to remove the $ at the end
            while (i < decryptHash.length - 6) {
                var name_1 = decryptHash
                    .substring(i, i + ENCRYPT_NAME_LENGTH)
                    .replace(/A+$/, "");
                i += ENCRYPT_NAME_LENGTH;
                var share = decryptHash
                    .substring(i, i + ENCRYPT_SHARES_NAME)
                    .replace(/^0+/, "");
                i += ENCRYPT_SHARES_NAME;
                buddyNames.push(name_1);
                shares.push(parseInt(share));
            }
            return [buddyNames, shares];
        }
    };
    Client.encryptHash = function (owners, shares) {
        var lastNumber = 1000;
        var stringToEncrypt = "";
        for (var i = 0; i < owners.length; i++) {
            var name_2 = owners[i].toLowerCase().padEnd(ENCRYPT_NAME_LENGTH, "A");
            var share = shares[i].toString().padStart(ENCRYPT_SHARES_NAME, "0");
            stringToEncrypt += name_2 + share;
        }
        stringToEncrypt += lastNumber.toString().padStart(5, "0");
        return encrypt(stringToEncrypt) + "$";
    };
    return Client;
}());
export { Client };
//# sourceMappingURL=Client.js.map