import { __assign, __awaiter, __generator } from "tslib";
import { TOKEN_PROGRAM_ID } from "@solana/spl-token";
import * as anchor from "@project-serum/anchor";
import { getTokenAccount } from "../../utils/pda";
import { getTreasuryPDA } from "../../utils/pda";
import { initTreasury } from "../init/initTreasury";
import { parsePublicKey } from "../../utils/parse";
import { MEMBER_NOT_EXIST, TREASURY_DOESNT_EXIST } from "../../utils/type";
export function transferRewardsNoMultiLevel(program, authority, memberPDA, amount, //With lamport decimals
mint, allowStats) {
    return __awaiter(this, void 0, void 0, function () {
        var instructions, member, treasuryPDA, treasury, mintTreasuryPDA, owners, shares, _i, _a, owner, mintTreasury, _b, _c, referrerMemberPDA, referrerMember, mintTreasuryATA, refereeTokenAccount, _d, _e;
        return __generator(this, function (_f) {
            switch (_f.label) {
                case 0:
                    instructions = [];
                    return [4 /*yield*/, program.account.member.fetchNullable(memberPDA)];
                case 1:
                    member = _f.sent();
                    if (!member)
                        throw MEMBER_NOT_EXIST;
                    treasuryPDA = member.referrer;
                    return [4 /*yield*/, program.account.treasury.fetchNullable(treasuryPDA)];
                case 2:
                    treasury = _f.sent();
                    if (!treasury)
                        throw TREASURY_DOESNT_EXIST;
                    mintTreasuryPDA = treasuryPDA;
                    if (!(treasury.mint.toString() !== mint.toString())) return [3 /*break*/, 5];
                    owners = [], shares = [];
                    for (_i = 0, _a = treasury.owners; _i < _a.length; _i++) {
                        owner = _a[_i];
                        owners.push(owner.ownerPda);
                        shares.push(owner.share);
                    }
                    mintTreasuryPDA = getTreasuryPDA(program, owners, shares, parsePublicKey(mint));
                    return [4 /*yield*/, program.account.treasury.fetchNullable(mintTreasuryPDA)];
                case 3:
                    mintTreasury = _f.sent();
                    if (!!mintTreasury) return [3 /*break*/, 5];
                    _c = (_b = instructions).push;
                    return [4 /*yield*/, initTreasury(program, authority, owners, shares, parsePublicKey(mint))];
                case 4:
                    _c.apply(_b, [_f.sent()]);
                    _f.label = 5;
                case 5:
                    referrerMemberPDA = null;
                    if (!allowStats) return [3 /*break*/, 7];
                    return [4 /*yield*/, program.account.member.all([
                            {
                                memcmp: {
                                    offset: 41,
                                    bytes: treasuryPDA.toBase58()
                                }
                            },
                        ])];
                case 6:
                    referrerMember = (_f.sent())[0];
                    referrerMemberPDA = (referrerMember === null || referrerMember === void 0 ? void 0 : referrerMember.publicKey) || null;
                    _f.label = 7;
                case 7: return [4 /*yield*/, getTokenAccount(mintTreasuryPDA, mint)];
                case 8:
                    mintTreasuryATA = _f.sent();
                    return [4 /*yield*/, getTokenAccount(authority, mint, false)];
                case 9:
                    refereeTokenAccount = _f.sent();
                    _e = (_d = instructions).push;
                    return [4 /*yield*/, program.methods
                            .transferRewardNoMultiLevel(new anchor.BN(amount))
                            .accounts(__assign(__assign({}, (parsePublicKey(mint)
                            ? { tokenProgram: TOKEN_PROGRAM_ID }
                            : { systemProgram: anchor.web3.SystemProgram.programId })), { authority: authority, referrerMember: referrerMemberPDA, referrerTreasury: treasuryPDA, referrerTreasuryForReward: mintTreasuryPDA, buddy: memberPDA, mint: parsePublicKey(treasury.mint), refereeTokenAccount: refereeTokenAccount, referrerTokenAccount: mintTreasuryATA }))
                            .instruction()];
                case 10:
                    _e.apply(_d, [_f.sent()]);
                    return [2 /*return*/, instructions];
            }
        });
    });
}
//# sourceMappingURL=transferRewardsNoMultiLevel.js.map