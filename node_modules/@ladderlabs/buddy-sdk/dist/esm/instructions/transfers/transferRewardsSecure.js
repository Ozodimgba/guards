import { __assign, __awaiter, __generator } from "tslib";
import { TOKEN_PROGRAM_ID } from "@solana/spl-token";
import * as anchor from "@project-serum/anchor";
import { getBuddyPDA, getTokenAccount, getTreasuryPDAByHash, } from "../../utils/pda";
import { getTreasuryPDA } from "../../utils/pda";
import { initTreasury } from "../init/initTreasury";
import { parsePublicKey } from "../../utils/parse";
import { BUDDY_DOESNT_EXIST, MEMBER_NOT_EXIST, REFERRER_TREASURY_DOESNT_EXIST, } from "../../utils/type";
export function transferRewardsSecure(program, authority, memberPDA, receiverMemberPDA, amount, //With lamport decimals
allowMultiLevel, mint, allowStats) {
    var _a;
    return __awaiter(this, void 0, void 0, function () {
        var instructions, member, referrerTreasuryPDA, referrerTreasury, mintTreasuryPDA, owners, shares, _i, _b, owner, mintTreasury, _c, _d, mintTreasuryATA, mintGlobalReferrerTreasuryATA, mintGlobalReferrerTreasuryPDA, globalReferrerTreasuryPDA, globalReferrerTreasury, owners, shares, _e, _f, owner, mintTreasury, _g, _h, refereeTokenAccount, buddyPDA, buddyProfilePDA, buddy, buddyProfile, referrerMemberPDA, referrerMember, _j, _k;
        return __generator(this, function (_l) {
            switch (_l.label) {
                case 0:
                    instructions = [];
                    return [4 /*yield*/, program.account.member.fetchNullable(memberPDA)];
                case 1:
                    member = _l.sent();
                    if (!member)
                        throw MEMBER_NOT_EXIST;
                    referrerTreasuryPDA = member.referrer;
                    return [4 /*yield*/, program.account.treasury.fetchNullable(referrerTreasuryPDA)];
                case 2:
                    referrerTreasury = _l.sent();
                    if (!referrerTreasury)
                        throw REFERRER_TREASURY_DOESNT_EXIST;
                    mintTreasuryPDA = referrerTreasuryPDA;
                    if (!(referrerTreasury.mint.toString() !== mint.toString())) return [3 /*break*/, 5];
                    owners = [], shares = [];
                    for (_i = 0, _b = referrerTreasury.owners; _i < _b.length; _i++) {
                        owner = _b[_i];
                        owners.push(owner.ownerPda);
                        shares.push(owner.share);
                    }
                    mintTreasuryPDA = getTreasuryPDA(program, owners, shares, parsePublicKey(mint));
                    return [4 /*yield*/, program.account.treasury.fetchNullable(mintTreasuryPDA)];
                case 3:
                    mintTreasury = _l.sent();
                    if (!!mintTreasury) return [3 /*break*/, 5];
                    _d = (_c = instructions).push;
                    return [4 /*yield*/, initTreasury(program, authority, owners, shares, parsePublicKey(mint))];
                case 4:
                    _d.apply(_c, [_l.sent()]);
                    _l.label = 5;
                case 5: return [4 /*yield*/, getTokenAccount(mintTreasuryPDA, mint)];
                case 6:
                    mintTreasuryATA = _l.sent();
                    mintGlobalReferrerTreasuryATA = null;
                    mintGlobalReferrerTreasuryPDA = null;
                    if (!(JSON.stringify(member.globalReferrerOfBuddy.referrerTreasuryOwnerHash) !==
                        JSON.stringify(new Array(32).fill(0)))) return [3 /*break*/, 12];
                    globalReferrerTreasuryPDA = getTreasuryPDAByHash(program, Buffer.from(member.globalReferrerOfBuddy.referrerTreasuryOwnerHash), parsePublicKey(mint));
                    return [4 /*yield*/, program.account.treasury.fetchNullable(globalReferrerTreasuryPDA)];
                case 7:
                    globalReferrerTreasury = _l.sent();
                    if (!globalReferrerTreasury)
                        throw REFERRER_TREASURY_DOESNT_EXIST;
                    owners = [], shares = [];
                    for (_e = 0, _f = globalReferrerTreasury.owners; _e < _f.length; _e++) {
                        owner = _f[_e];
                        owners.push(owner.ownerPda);
                        shares.push(owner.share);
                    }
                    mintGlobalReferrerTreasuryPDA = getTreasuryPDA(program, owners, shares, parsePublicKey(mint));
                    return [4 /*yield*/, program.account.treasury.fetchNullable(mintGlobalReferrerTreasuryPDA)];
                case 8:
                    mintTreasury = _l.sent();
                    if (!!mintTreasury) return [3 /*break*/, 10];
                    _h = (_g = instructions).push;
                    return [4 /*yield*/, initTreasury(program, authority, owners, shares, parsePublicKey(mint))];
                case 9:
                    _h.apply(_g, [_l.sent()]);
                    _l.label = 10;
                case 10: return [4 /*yield*/, getTokenAccount(mintGlobalReferrerTreasuryPDA, mint)];
                case 11:
                    mintGlobalReferrerTreasuryATA = _l.sent();
                    _l.label = 12;
                case 12: return [4 /*yield*/, getTokenAccount(authority, mint)];
                case 13:
                    refereeTokenAccount = _l.sent();
                    buddyPDA = getBuddyPDA(program, member.name);
                    buddyProfilePDA = buddyPDA;
                    return [4 /*yield*/, program.account.buddy.fetchNullable(buddyPDA)];
                case 14:
                    buddy = _l.sent();
                    if (!buddy)
                        throw BUDDY_DOESNT_EXIST;
                    if (!!((_a = buddy.buddyType) === null || _a === void 0 ? void 0 : _a.profile)) return [3 /*break*/, 16];
                    return [4 /*yield*/, program.account.buddy.all([
                            { memcmp: { offset: 8, bytes: authority.toBase58() } },
                        ])];
                case 15:
                    buddyProfile = (_l.sent())[0];
                    // finalBuddy = buddyProfile.account;
                    buddyProfilePDA = buddyProfile.publicKey;
                    _l.label = 16;
                case 16:
                    // Check if paid global buddy is owned by authority
                    if (buddy.authority.toString() !== buddyProfilePDA.toString() &&
                        !buddy.buddyType.profile) {
                        buddyPDA = buddyProfilePDA;
                    }
                    referrerMemberPDA = null;
                    if (!allowStats) return [3 /*break*/, 18];
                    return [4 /*yield*/, program.account.member.all([
                            {
                                memcmp: {
                                    offset: 41,
                                    bytes: mintTreasuryPDA.toBase58()
                                }
                            },
                        ])];
                case 17:
                    referrerMember = (_l.sent())[0];
                    referrerMemberPDA = (referrerMember === null || referrerMember === void 0 ? void 0 : referrerMember.publicKey) || null;
                    _l.label = 18;
                case 18:
                    _k = (_j = instructions).push;
                    return [4 /*yield*/, program.methods
                            .transferRewardSecure(new anchor.BN(amount), allowMultiLevel)
                            .accounts(__assign({ authority: authority, buddyGlobalReferrerTreasury: mintGlobalReferrerTreasuryPDA, buddyGlobalReferrerTokenAccount: mintGlobalReferrerTreasuryATA, referrerMember: referrerMemberPDA, referrer: receiverMemberPDA, referrerTreasury: mintTreasuryPDA, buddyProfile: buddyProfilePDA, buddy: buddyPDA, buddyTreasury: member.owner, member: memberPDA, mint: parsePublicKey(mint), refereeTokenAccount: refereeTokenAccount, referrerTokenAccount: mintTreasuryATA }, (refereeTokenAccount
                            ? {
                                tokenProgram: TOKEN_PROGRAM_ID
                            }
                            : {
                                systemProgram: anchor.web3.SystemProgram.programId
                            })))
                            .instruction()];
                case 19:
                    _k.apply(_j, [_l.sent()]);
                    return [2 /*return*/, instructions];
            }
        });
    });
}
//# sourceMappingURL=transferRewardsSecure.js.map